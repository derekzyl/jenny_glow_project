import paginate from '../../paginate/paginate';
import toJSON from '../../toJSON/toJSON';
import mongoose from 'mongoose';
import { transactionTypes } from '../../../config/transactions';
const cryptoTransactionSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'USERS',
        required: true,
    },
    walletId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'CRYPTO_HD_WALLETS',
    },
    referenceId: {
        type: String,
        required: true,
        unique: true,
    },
    type: {
        type: String,
        required: true,
        uppercase: true,
        enum: transactionTypes,
    },
    txHash: {
        type: String,
        sparse: true,
        unique: true,
        default: '',
    },
    amount: {
        type: String,
        required: true,
    },
    fromAddress: {
        type: String,
    },
    toAddress: {
        type: String,
    },
    confirmations: {
        type: Number,
        default: 0,
    },
    isConfirmed: {
        type: Boolean,
        default: false,
    },
    status: {
        type: String,
        enum: ['PENDING', 'SUCCESS', 'AWAITING_CONFIRMATION', 'FAILED'],
        default: 'PENDING',
        required: true,
    },
    uid: {
        type: String,
        required: true,
        unique: true, // Enforce unique UIDs
    },
    assetType: String,
    chain: String,
    network: String,
    fee: String,
    description: {
        type: String,
    },
    ref: String,
    tos: [{ value: String, address: String }],
    from: [{ value: String, address: String, chain: String, currency: String, index: Number }],
    memo: String,
    bitpwrType: {
        type: String,
        /*    enum: ['TRANSFER', 'DEPOSIT', 'SWAP'], */
    },
    assetId: String,
    category: {
        type: String,
        enum: ['transfer', 'deposit', 'swap'],
    },
    gasLimit: Number,
    gasPrice: Number,
    accountId: String,
    blockHash: String,
    operation: String,
    customerId: String,
    blockHeight: String,
    errorReason: String,
    errorMessage: String,
    confirmation: Number,
    broadcastedAt: String,
    senderAddress: String,
}, {
    timestamps: true,
});
// add plugin that converts mongoose to json
cryptoTransactionSchema.plugin(toJSON);
cryptoTransactionSchema.plugin(paginate);
/**
 * Check if transaction exists - to avoid duplicate transactions
 * @param {string} type - The type of the transaction
 * @param {string} referenceId - The transaction reference id - generated by the server
 * @param {string} txHash - The transaction hash
 * @param {mongoose.Types.ObjectId} [excludeTxId] - The id of the transaction to be excluded
 * @returns {Promise<boolean>}
 */
cryptoTransactionSchema.static('isExists', async function (type, referenceId, txHash, excludeTxId) {
    const transaction = await this.findOne(Object.assign(Object.assign({ type,
        referenceId }, (txHash !== undefined && { txHash })), { _id: { $ne: excludeTxId } }));
    return !!transaction;
});
const CRYPTO_TRANSACTIONS = mongoose.model('CRYPTO_TRANSACTIONS', cryptoTransactionSchema);
export default CRYPTO_TRANSACTIONS;
//# sourceMappingURL=model.crypto.transactions.js.map